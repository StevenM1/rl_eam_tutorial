---
title: "A step-by-step guide to reinforcement learning evidence accumulation models of instrumental learning tasks"
author: "Steven MiletiÄ‡, Niek Stevenson, (some other people probably), Andrew Heathcote"
date: "`r format(Sys.time(), '%d %B, %Y')`"
bibliography: bibliography.bib
link-citations: true
output:
  pdf_document:
    highlight: pygments
    includes:
      in_header: preamble.tex
header-includes:
  - \usepackage{tikz}
  - \usetikzlibrary{positioning}
  - \usepackage[framemethod=tikz]{mdframed}
  - \definecolor{shadecolor}{RGB}{230,235,255}
  - |
    \mdfdefinestyle{rcode}{
      backgroundcolor = shadecolor,
      linecolor       = gray,
      linewidth       = .5pt,     % stronger border
      roundcorner     = 1pt,
      innerleftmargin = 4pt,      % generous padding
      innerrightmargin= 4pt,
      innertopmargin  = 2pt,
      innerbottommargin = 2pt
    }
    \renewenvironment{Shaded}{\begin{mdframed}[style=rcode]}{\end{mdframed}}
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, comment = NA,
                      results='markup', fig.path="figs/")
```

# Introduction

In this tutorial, we will demonstrate how to design combinations of reinforcement learning and evidence accumulation models (RL-EAMs) and fit them to data from instrumental learning tasks using hierarchical Bayesian methods. We will utilize the *EMC2* package, assuming some prior knowledge of its functionalities (for reference, see the *EMC2* tutorial [@stevensonEMC2PackageCognitive2024]). 

First, let's load the required packages and data (note that you will also need the Hmisc package installed):

```{r set-up}
rm(list = ls())
# TMP -- install the right branch
# remotes::install_github("ampl-psych/EMC2@trendy_customkernel_fix",dependencies=TRUE, Ncpus=8);.rs.restartR()
# END TMP
library(EMC2)
library(Hmisc)
set.seed(1) # for reproducibility

# This is some code that contains plotting functions used later on in this tutorial
if(Sys.info()[['nodename']] == 'tux22psy') {
  # load local if present
  code_url = './RL_plotting_utils.R'
} else {
  code_url <- paste0(
    "https://raw.githubusercontent.com/StevenM1/",
    "rl_eam_tutorial/refs/heads/main/RL_plotting_utils.R")
}
source(code_url)

```

# From data to a basic RL-EAM: the RL-RD
While *EMC2* is flexibly designed to allow researchers to implement any mapping, in most applications of RL-EAMs, it is assumed that drift rates are a linear function of the Q-values. Key is to map the Q-values to the accumulator drift rates. This entails that we:

1. Specify the covariates in the data;
2. Apply the delta-rule to each covariate separately;
3. Define the trial-wise mapping between covariates and each accumulator.



\begin{figure}
\begin{tikzpicture}[
    node distance=1.0cm,
    box/.style={rectangle, draw, rounded corners, text width=2.5cm, minimum height=1cm, align=center},
    vblock/.style={anchor=north, draw, rounded corners, align=center}
]

\node[box, text width=4.5cm] (data) {Data};
\node[vblock, text width=4.5cm, below=0.25cm of data] (data_tab) {
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
    R rew s_left s_right
 left   1    s_D     s_e
right   0    s_T     s_t
right   0    s_e     s_D
 left   1    s_D     s_e
 left   1    s_T     s_t
right   1    s_t     s_T
\end{lstlisting}
};

\node[box, text width=6.0cm, right=3cm of data] (dadm) {DADM};
\node[vblock, text width=6.0cm, below=0.25cm of dadm] (dadm_tab) {
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
 t     R    lR s_D s_e s_T s_t
 1  left  left   1  NA  NA  NA
 1  left right   1  NA  NA  NA
 2 right  left  NA  NA  NA   0
 2 right right  NA  NA  NA   0
 3 right  left   0  NA  NA  NA
 3 right right   0  NA  NA  NA
 9  left  left   1  NA  NA  NA
 9  left right   1  NA  NA  NA
10  left  left  NA  NA   1  NA
10  left right  NA  NA   1  NA
11 right  left  NA  NA   1  NA
11 right right  NA  NA   1  NA
\end{lstlisting}
};
\node[box, text width=1.0cm, right=0.5cm of dadm] (rates) {Drift\\rates};
\node[vblock, text width=1.0cm, below=0.25cm of rates] (rates_tab) {
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
  v
0.0
0.0
0.0
0.0
0.0
0.5
0.4
0.0
0.0
0.0
0.0
0.5
\end{lstlisting}
};

\node[box, text width=3.5cm, below=2.5cm of data_tab] (covmap) {Covariate map};
\node[box, text width=3.5cm, right=1.0cm of covmap] (deltarule) {Delta rule};
\node[vblock, text width=3.5cm, below=0.25cm of covmap] (covmap_tab) {
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
s_D s_e s_T s_t
  1   0   0   0
  0   1   0   0
  0   0   1   0
  0   0   0   1
  0   1   0   0
  1   0   0   0
  1   0   0   0
  0   1   0   0
  0   0   1   0
  0   0   0   1
  0   0   0   1
  0   0   1   0
\end{lstlisting}
};

\node[vblock, text width=3.5cm, below=0.25cm of deltarule] (deltarule_tab) {
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
  s_D s_e s_T s_t
0.000   0 0.0   0
0.000   0 0.0   0
0.200   0 0.0   0
0.200   0 0.0   0
0.200   0 0.0   0
0.200   0 0.0   0
0.160   0 0.0   0
0.160   0 0.0   0
0.328   0 0.0   0
0.328   0 0.0   0
0.328   0 0.2   0
0.328   0 0.2   0
\end{lstlisting}
};


\node[box, text width=1.5cm, right=1cm of deltarule] (weight) {Weight};
\node[vblock, text width=1.5cm, below=0.25cm of weight] (weight_tab) {
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
  w
2.5
2.5
2.5
2.5
2.5
2.5
2.5
2.5
2.5
2.5
2.5
2.5
\end{lstlisting}
};


% more arrows
%\draw[->] (data) -- (dadm);
\draw[->] (data_tab) -- node[midway, sloped, above, font=\footnotesize] {design(\textbf{functions}, ...)} (dadm_tab);
\draw[->] (dadm_tab) -- (deltarule);
\draw[->] (dadm_tab) -- node[midway, sloped, above, font=\footnotesize] {make\_trend(\textbf{map}, ...)} (covmap);
\draw[->] (covmap_tab) -- node[midway, sloped, above, font=\footnotesize] {$\times$} (deltarule_tab);
\draw[->] (deltarule_tab) -- node[midway, sloped, above, font=\footnotesize] {$\times$} (weight_tab);
\draw[->] (weight_tab.east) -- node[midway, sloped, above, font=\footnotesize] {row sums} (rates_tab);


\end{tikzpicture}
\caption{Overview of steps. Users need to specify functions in two places. First, a set of functions that can be applied to the \texttt{dadm} and generates the covariate columns (here, \texttt{s\_D, s\_e, s\_T, s\_t}). These functions are supplied to the \texttt{design()} function of \texttt{EMC2}. Second, a set of functions that can be applied to the \texttt{dadm} and generates one (or optionally more) covariate map(s). These are supplied to \texttt{make\_trend()}. The trial-wise drift rate is the rowsum of the updated covariate multiplied by the covariate map(s) and the weight.}
\end{figure}




### 1. Covariate specification
In this section, we start by formatting the empirical data. We start by downloading dataset 1 from [@Miletic2021]. It contains 24 variables; here, we aim to extract the minimum we need for modelling the data. Some are columns that *EMC2* always requires for choice tasks: columns indicating subject number (`subjects`), stimulus (`S`), and response and response time (`R`, `rt`). `S` and `R` are usually response-coded, meaning they typically refer to the response location or hand (left/right) or response button (e.g., 'z', 'm', 'left arrow key'). Let us start with extracting those:

```{r load_data}
load('./data/data_exp1.RData')
# exclude subjects based on criteria of Miletic et al 2021
dat <- dat[!dat$excl,]
# exclude trials without a response
dat <- dat[!is.na(dat$rt),]

# Format subjects as factor and rename column
dat$subjects <- as.factor(dat$pp)

# Format response to factor: left or right
dat$R <- factor(dat$choiceDirection, levels=c('left', 'right'))

# In order to determine which direction was 'optimal', we can check
# whether p_win_left was larger than p_win_right
dat$S <- factor(ifelse(dat$p_win_left>dat$p_win_right, 'left', 'right'),
                levels=c('left', 'right'))
head(dat[,c('subjects', 'S', 'R', 'rt')])
```

Instrumental learning tasks minimally add two pieces of information: the `feedback` (or `reward`) given on each trial, and the `symbol` that the feedback was associated with. It is not necessary that the feedback corresponds to the *chosen* symbol, as the case of experiments with counterfactual feedback [@palminteriConfirmationBiasHuman2017; @Palminteri2015] demonstrates - we only need to know to *which* symbol the feedback corresponds. Let's extract these:

```{r load_data_2}
# In this experiment, there's both an `outcome` and `reward` column;
# in this specific experiment these are the same, but in later experiments
# in the same paper these could differ. Here, we arbitrarily pick `reward`,
# and recode it to [0, 1]
dat$reward <- dat$reward / 100

# Let's extract the symbols that were presented as `s_left` and `s_right`.
# and let's add a prefix "s_"
dat$s_left <- paste0('s_', dat$appear_left)
dat$s_right <- paste0('s_', dat$appear_right)

head(dat[,c('subjects', 'S', 'R', 'rt', 'reward', 's_left', 's_right')])
# based on the combination of R and s_left and s_right, we can now determine
# which symbol was chosen, and thus, corresponds to the reward.
```

Additionally, for simulating new data (but strictly speaking not for fitting), we need to be able to generate feedback in the same way that feedback was generated in the experiment. In the easiest case, feedback is deterministic and a feedback generator will simply map a chosen symbol to a corresponding reward. In more realistic examples it will require sampling a random number from a binomial or Gaussian distribution, with the parameters of that distribution varying between symbols. As such, for simulating new data and assessing quality of fit, we need to know the feedback distribution parameters for each symbol and trial.

```{r load_data_3}
dat$p_left <- dat$p_win_left
dat$p_right <- dat$p_win_right

dat <- dat[,c('subjects', 'S', 'R', 'rt', 'reward',
              's_left', 's_right', 'p_left', 'p_right')]
head(dat)
```

Note that the column names of `reward`, `s_left`, `s_right`, `p_left`, and `p_right` are arbitrary - as long as the user's own functions (see the next section) refer to the correct columns, their names can be anything.

For fitting in *EMC2*, we need to create one column per symbol, with the values indicating the feedback. If no feedback was given on the symbol, the value should be `NA`. An intuitive option would be to add such columns to the data. However, all columns in the data (except for `rt` and `R`) are assumed to be static factors of the design. Keep in mind that we also want to be able to *simulate* new data. And once we simulate new data, the covariate columns should depend on the simulated behavior - that is, the covariate columns are *not* factors of the experimental design, and should not be treated as such.
For this reason, we should not add the covariate columns to the data directly, but rather define *functions* that create covariate columns based on the data. When simulating new data, these functions are re-applied after each trial, ensuring that the covariate columns are correct for simulated data. Here's the idea:

```{r define_covariates}
make_covariate_column <- function(data, covariate_symbol) {
    # Which response symbol (RS) was chosen?
    RS <- ifelse(data$R=='left', data$s_left, data$s_right)
    data[,covariate_symbol] <- NA
    data[RS == covariate_symbol, covariate_symbol] <- data[RS == covariate_symbol, 'reward']
    data[[covariate_symbol]]
}

tmp <- dat
tmp$s_D <- make_covariate_column(tmp, "s_D")
tmp$s_e <- make_covariate_column(tmp, "s_e")
tmp$s_t <- make_covariate_column(tmp, "s_t")
head(tmp)

# To facilitate, we can wrap this with a function generator -
# that is, a function that returns a function, one for each column
# Each of those returned function generates a covariate column
# with the appropriate structure.
covariate_column_generator <- function(col_name) {
  function(data) {
    # Which response symbol was chosen?
    RS <- ifelse(data$R=='left', data$s_left, data$s_right)
    data[,col_name] <- NA
    data[RS == col_name, col_name] <- data[RS == col_name, 'reward']
    data[[col_name]]
  }
}

all_symbols <- unique(c(dat$s_left, dat$s_right))
make_covariate_columns <- setNames(lapply(all_symbols,
                                          covariate_column_generator), all_symbols)
```
Now, `make_covariate_columns` is a list of functions that should be applied to the data. We can tell *EMC2* to do this by providing the functions to the `design`:

```{r design_baseline_rdm}
design_RDM <- design(model=RDM,
                     data=dat,
                     functions=make_covariate_columns,
                     matchfun=function(d) d$S==d$lR,
                     formula=list(B ~ 1, v ~ 1, t0 ~ 1),
                     report_p_vector = FALSE)

# Once the design is combined with the data, the functions are applied.
# and we can find all covariate columns in the `dadm`:
emc <- make_emc(dat, design_RDM)
head(emc[[1]]$data[[1]])
```


### 2. Apply the delta rule
Handling trialwise covariates works through `trend` objects in *EMC2*. In this object, you specify (1) the covariate of interest, (2) a kernel to apply to the covariate, and (3) which decision parameter is informed by the resulting covariate, and (4) the functional form of the mapping between the resulting covariate and the decision parameters, referred to as the 'base'.
Now that we have prepared the data-augmented design matrix (`dadm`) (so that it contains all covariates as columns), we can now specify a `trend` object. The kernel that we want to apply is the `delta` rule, and it should inform drift rates `v` linearly, so we use a `lin`ear `base`.

```{r delta_rule}
trend <- make_trend(par_names='v',
                    cov_names=list(all_symbols),
                    kernels='delta',
                    bases='lin',
                    phase='posttransform')

design_RDM <- design(model=RDM,
                     data=dat,
                     functions=make_covariate_columns,
                     matchfun=function(d) d$S==d$lR,
                     formula=list(B ~ 1, v ~ 1, t0 ~ 1),
                     trend=trend,
                     report_p_vector = FALSE)

emc <- make_emc(dat, design_RDM)

# To illustrate the effect
kernel_pars <- c('v.q0'=0, 'v.alpha'=0.2)
head(cbind(emc[[1]]$data[[1]][,all_symbols], apply_kernel(kernel_pars, emc = emc, subject=1)))
```


### 3. Define the trial-wise mapping between covariates and each accumulator
By default, *EMC2* applies the base to all updated covariates (i.e., it multiplies the base with the rowsums of the updated kernel). However, on each trial, only two stimuli were shown, so only they should influence the respective drift rates. Therefore, we need to create a mapping between covariates and accumulators. Such a map is a matrix specifying the weight of each covariate for each drift rate - most will be 0. The simplest type of map corresponds to an RL-RD, which just maps 1 covariate to 1 accumulator in each row:

```{r rlrd_make_mapping}
make_RL_RD_map <- function(dadm, cov_names) {
  dadm$lS <- NA
  dadm[dadm$lR=='left', 'lS'] <- dadm[dadm$lR=='left', 's_left']
  dadm[dadm$lR=='right', 'lS'] <- dadm[dadm$lR=='right', 's_right']

  # Return 1 if the column name matches the accumulator's latent stimulus
  # and 0 otherwise
  map <- sapply(cov_names, function(col) ifelse(dadm$lS == col, 1, 0))
  map
}

head(make_RL_RD_map(emc[[1]]$data[[1]], all_symbols))

# Combine with trend and design
trend <- make_trend(par_names='v',
                    cov_names=list(all_symbols),
                    kernels='delta',
                    bases='lin',
                    phase='posttransform',
                    maps = list(make_RL_RD_map))

design_RDM <- design(model=RDM,
                     data=dat,
                     functions=make_covariate_columns,
                     matchfun=function(d) d$S==d$lR,
                     formula=list(B ~ 1, v ~ 1, t0 ~ 1),
                     trend=trend,
                     constants=c('v.q0'=0),
                     report_p_vector = FALSE)

emc <- make_emc(dat, design_RDM)
```

```{r get_verbatim_examples, include=FALSE, eval=FALSE}
symcolns <- c('s_D', 's_e', 's_T', 's_t')
tmp <- emc[[1]]$data[[1]][,c('trials', 'S', 'R', 'rt', 'lR', 'reward', 's_left', 's_right', 's_D', 's_e', 's_T', 's_t')] # 1, 3, 2, 7
tmp$rt <- round(tmp$rt,3)
rowidx1 <- tmp$s_left%in% c('s_D', 's_e', 's_T', 's_t')
tmp <- tmp[rowidx1,]
tmp[seq(1, 12, 2),]

kernel_pars <- c('v.q0'=0, 'v.alpha'=0.2)
tmp2 <- apply_kernel(kernel_pars, emc = emc, subject=1)
tmp2 <- tmp2[rowidx1, c(1,3,2,7)]
colnames(tmp2) <- c('s_D', 's_e', 's_T', 's_t')
tmp2[seq(1,12,2),]

## example 2: In dadm space
dadm <- tmp#[c()]
updated_covs <- tmp2
tmp3 <- attr(emc[[1]]$data[[1]], 'covariate_maps')[[1]]
tmp3[rowidx1,]

dadm[1:12,c('trials', 'R', 'lR',  c('s_D', 's_e', 's_T', 's_t'))]
updated_covs[1:12,]
tmp3[rowidx1,c(1,3,2,7)][1:12,]

dadm_example <- dadm[1:12,c('trials', 'R', 'lR',  c('s_D', 's_e', 's_T', 's_t'))]
colnames(dadm_example)[1] <- 't'
dadm_example

updated_covs[1:12,]

## drift rates?
rowSums(updated_covs[1:12,]*tmp3[rowidx1,c(1,3,2,7)][1:12,]*2.5)
```

Note how the drift rate is now only influenced by the covariate that corresponds to the symbol that the accumulator codes for.

We are now ready to fit the RL-RD!

```{r fit_rlrd, eval=FALSE}
emc <- fit(emc, cores_per_chain=20, fileName='./samples/exp1_subset_rlrd.RData')
```

```{r pp_rlrd}
load('./samples/exp1_subset_rlrd.RData')
ppC <- predict(emc, n_post=20, n_cores=50)
plot_exp1(dat=dat, pp=ppC)
```

### 4. Feedback generator
***ToDo: Add a feedback generator function. This requires more work on EMC2 for a principled implementation.***
Need to check with Niek

## Example: RL-DDM
The above illustrates the basics, and with these, it is straightforward to construct other RL-EAMs. In most cases, it is a matter of changing the mapping function, and potentially the EAM itself. For example, a popular choice is the RL-DDM, which is the following:

```{r make_rlddm}
make_RL_DDM_map <- function(dadm, cov_names) {
  # Here, we simply find the symbol on the left and right,
  # and subtract one from the other
  map_left <- sapply(cov_names, function(col) ifelse(dadm$s_left == col, 1, 0))
  map_right <- sapply(cov_names, function(col) ifelse(dadm$s_right == col, 1, 0))
  map <- map_left-map_right
  map
}

# Combine with trend and design
trend <- make_trend(par_names='v',
                    cov_names=list(all_symbols),
                    kernels='delta',
                    bases='lin',
                    phase='posttransform',
                    maps = list(make_RL_DDM_map))

design_DDM <- design(model=DDM,
                     data=dat,
                     functions=make_covariate_columns,
                     matchfun=function(d) d$S==d$lR,
                     formula=list(a ~ 1, v ~ 1, t0 ~ 1),
                     trend=trend,
                     constants=c('v.q0'=0),
                     report_p_vector = FALSE)

emc <- make_emc(dat, design_DDM)
head(attr(emc[[1]]$data[[1]], 'covariate_maps')[[1]])
```
```{r fit_rlddm, eval=FALSE}
emc <- fit(emc, cores_per_chain=20, fileName='./samples/exp1_subset_rlddm.RData')
```

However, the RL-DDM does not fit the response time distributions very well:

```{r pp_rlddm}
## plot here
load('./samples/exp1_subset_rlddm.RData')
ppC <- predict(emc, n_post=20, n_cores=50)
plot_exp1(dat=dat, pp=ppC)
```

## Example: RL-ARD
An alternative option is the RL-ARD, which combines a difference and a sum map in a race architecture:

```{r make_rlard}
make_RL_ARD_difference <- function(dadm, cov_names) {
  dadm$lS <- NA
  dadm[dadm$lR=='left', 'lS'] <- dadm[dadm$lR=='left', 's_left']
  dadm[dadm$lR=='right', 'lS'] <- dadm[dadm$lR=='right', 's_right']

  dadm$lSother <- NA
  dadm[dadm$lR=='left', 'lSother'] <- dadm[dadm$lR=='left', 's_right']
  dadm[dadm$lR=='right', 'lSother'] <- dadm[dadm$lR=='right', 's_left']

  # Return 1 if the column name matches the accumulator's latent stimulus
  # Return -1 if the column name matches the *other* accumulator's latent stimulus
  # and 0 otherwise
  maplS <- sapply(cov_names, function(col) ifelse(dadm$lS == col, 1, 0))
  maplSother <- sapply(cov_names, function(col) ifelse(dadm$lSother == col, 1, 0))
  maplS-maplSother
}

make_RL_ARD_sum <- function(dadm, cov_names) {
  dadm$lS <- NA
  dadm[dadm$lR=='left', 'lS'] <- dadm[dadm$lR=='left', 's_left']
  dadm[dadm$lR=='right', 'lS'] <- dadm[dadm$lR=='right', 's_right']

  dadm$lSother <- NA
  dadm[dadm$lR=='left', 'lSother'] <- dadm[dadm$lR=='left', 's_right']
  dadm[dadm$lR=='right', 'lSother'] <- dadm[dadm$lR=='right', 's_left']

  # Return 1 if the column name matches the accumulator's latent stimulus
  # Return 1 if the column name matches the *other* accumulator's latent stimulus
  # and 0 otherwise
  maplS <- sapply(cov_names, function(col) ifelse(dadm$lS == col, 1, 0))
  maplSother <- sapply(cov_names, function(col) ifelse(dadm$lSother == col, 1, 0))
  maplS+maplSother
}

# Combine with trend and design
trend <- make_trend(par_names='v',
                    cov_names=list(all_symbols),
                    kernels='delta',
                    bases='lin',
                    phase='posttransform',
                    maps = list('d'=make_RL_ARD_difference,
                                's'=make_RL_ARD_sum))

design_RDM <- design(model=RDM,
                     data=dat,
                     functions=make_covariate_columns,
                     matchfun=function(d) d$S==d$lR,
                     formula=list(B ~ 1, v ~ 1, t0 ~ 1),
                     trend=trend,
                     constants=c('v.q0'=0),
                     report_p_vector = FALSE)

emc <- make_emc(dat, design_RDM)
```

```{r fit_rlard, eval=FALSE}
emc <- fit(emc, cores_per_chain=20, fileName='./samples/exp1_subset_rlard.RData')
```

```{r pp_rlard}
load('./samples/exp1_subset_rlard.RData')
ppC <- predict(emc, n_post=20, n_cores=50)
# # ppC[is.infinite(ppC$rt),]
# # tpars <- attr(ppC, 'trialwise_parameters')[[1]]
# # dadm <- emc[[1]]$data[[1]]
# # tpars[dadm$subjects==7&dadm$trials==70,]
#
plot_exp1(dat=dat, pp=ppC)
```


# Section on factors on parameters


# Section on learning rules


# Section on counterfactual feedback


# Section on multi-alternative choice?


# Section on the two-stage task?